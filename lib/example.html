{ 
 "fullName": "test", 
 "mobile": "0356879768",  "nationalId": "HCM", 
 "referralAgent": "600000012",  "policyNumber": "76062238", }

 /lead/saveReferraInfo 

https://pru-api-nprd.prudential.com.vn/pruforce/lead-corporate/uat1


Environment URL
uat https://pru-api-nprd.prudential.com.vn/pruforce/lead-corporate/uat1

https://vn-lead-corporate-uat.aks-lb1-vnlife-uat-az2-
orch2h.pru.intranet.asia

prod https://pru-api-prod.prudential.com.vn/pruforce/lead-corporate/v1

Auth login
❖ API Description
- Purpose: This API is used to get token
- Method: POST
- URL: /auth/login


4. Save Referral Information
❖ API Description
- Purpose: This API is used to save information of referral agent
- Method: POST
- URL: /lead/saveReferraInfo

{
"fullName": "test",
"mobile": "0356879768",
"nationalId": "HCM",
"referralAgent": "600000012",
"policyNumber": "76062238",
}

Save Lead Referral
❖ API Description
- Purpose: This API is used to save lead which had referred by agent
- Method: POST
- URL: /lead/saveCorpWebReferral

{
"fullName": "viet Test",
"mobile": "0346786789",
"email": "test@gmail.com",
"referralId": "b5c53bff-5614-4f15-
9956-9a26ca715de7",
"referralAgent": "60000012",
"location": "HCM",
“messageDetails”: “remark string”,
“leadSource”:”test”
}

Check Identify Number
❖ API Description
- Purpose: This API is used to check identify of client was exist
- Method: POST
- URL: /lead/check-identify

{
“identifyNo:” 012005431233”
}


{
"referralId": "f4056f6c-dd22-4a64-
831a-3e53f1cd8e98",
"referralAgent": "600000012"
}

https://sgrasstvn4yt5w9.pru.intranet.asia:8443/opencms/vi/referee-form/index.html?uniqueId=ABC123&agentCode=001

https://pru-api-nprd.prudential.com.vn/pruforce/lead-corporate/uat1/auth/login


</html>

This form must be accessed through a valid referral link.


import java.net.URL;
import java.net.HttpURLConnection;
import java.net.InetAddress;
import java.io.OutputStreamWriter;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import java.security.cert.X509Certificate;

// Initialize log collection
StringBuilder logOutput = new StringBuilder();
String errorMessage = "";
int statusCode = 200; // Default success
boolean hasError = false;

HttpURLConnection con = null;
OutputStreamWriter os = null;
BufferedReader in = null;

try {
    // 1. NETWORK DIAGNOSTICS
    logOutput.append("=== NETWORK DIAGNOSTICS ===\n");
    
    // Test DNS resolution
    try {
        InetAddress address = InetAddress.getByName("pru-api-nprd.prudentialthailand.co.th");
        logOutput.append("DNS Resolution successful: ").append(address.getHostAddress()).append("\n");
    } catch (Exception e) {
        errorMessage = "DNS Resolution failed: " + e.getMessage();
        logOutput.append(errorMessage).append("\n");
        hasError = true;
        statusCode = 500;
        out.print(responeObject(statusCode, errorMessage + "\nLog:\n" + logOutput.toString()));
        return; // Exit if DNS fails
    }
    
    // 2. SYSTEM PROPERTIES DIAGNOSTICS
    logOutput.append("=== SYSTEM PROPERTIES ===\n");
    logOutput.append("Java version: ").append(System.getProperty("java.version")).append("\n");
    logOutput.append("HTTP proxy host: ").append(System.getProperty("http.proxyHost")).append("\n");
    logOutput.append("HTTPS proxy host: ").append(System.getProperty("https.proxyHost")).append("\n");
    logOutput.append("HTTP proxy port: ").append(System.getProperty("http.proxyPort")).append("\n");
    logOutput.append("HTTPS proxy port: ").append(System.getProperty("https.proxyPort")).append("\n");
    logOutput.append("Non proxy hosts: ").append(System.getProperty("http.nonProxyHosts")).append("\n");
    
    // 3. SSL/TLS CONFIGURATION for older Java versions
    logOutput.append("=== SSL/TLS CONFIGURATION ===\n");
    
    // Enable all TLS versions for older Java
    System.setProperty("https.protocols", "TLSv1,TLSv1.1,TLSv1.2");
    System.setProperty("jsse.enableSNIExtension", "false");
    logOutput.append("SSL protocols set to: TLSv1,TLSv1.1,TLSv1.2\n");
    logOutput.append("SNI extension disabled\n");
    
    // For very old Java versions, you might need to trust all certificates (NOT for production)
    TrustManager[] trustAllCerts = new TrustManager[] {
        new X509TrustManager() {
            public X509Certificate[] getAcceptedIssuers() { return null; }
            public void checkClientTrusted(X509Certificate[] certs, String authType) { }
            public void checkServerTrusted(X509Certificate[] certs, String authType) { }
        }
    };
    
    SSLContext sc = SSLContext.getInstance("SSL");
    sc.init(null, trustAllCerts, new java.security.SecureRandom());
    HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
    logOutput.append("SSL context configured to trust all certificates\n");
    
    // 4. CREATE CONNECTION WITH EXTENSIVE CONFIGURATION
    logOutput.append("=== CONNECTION SETUP ===\n");
    
    URL url = new URL("https://pru-api-nprd.prudentialthailand.co.th/pru-service/uat1/auth/login");
    logOutput.append("Target URL: ").append(url.toString()).append("\n");
    
    con = (HttpURLConnection) url.openConnection();
    
    // Set all possible headers to mimic Postman
    con.setRequestProperty("Content-Type", "application/json");
    con.setRequestProperty("Accept", "application/json");
    con.setRequestProperty("User-Agent", "Java-OpenCms/9.5.1");
    con.setRequestProperty("Connection", "close"); // Force connection closure
    con.setRequestProperty("Cache-Control", "no-cache");
    
    con.setRequestMethod("POST");
    con.setDoOutput(true);
    con.setDoInput(true);
    con.setUseCaches(false);
    
    // CRITICAL: Much shorter timeouts for testing
    con.setConnectTimeout(10000); // 10 seconds
    con.setReadTimeout(15000);    // 15 seconds
    
    logOutput.append("Connection timeout: ").append(con.getConnectTimeout()).append("ms\n");
    logOutput.append("Read timeout: ").append(con.getReadTimeout()).append("ms\n");
    logOutput.append("Request method: ").append(con.getRequestMethod()).append("\n");
    logOutput.append("Headers set: Content-Type, Accept, User-Agent, Connection, Cache-Control\n");
    
    // 5. PREPARE JSON DATA
    JSONObject jsonObject = new JSONObject();
    jsonObject.put("password", "your_password_here"); // Replace with actual
    jsonObject.put("username", "your_username_here"); // Replace with actual
    
    String jsonString = jsonObject.toString();
    logOutput.append("JSON payload prepared: ").append(jsonString).append("\n");
    
    byte[] jsonBytes = jsonString.getBytes("UTF-8");
    con.setFixedLengthStreamingMode(jsonBytes.length);
    logOutput.append("Content length set to: ").append(jsonBytes.length).append(" bytes\n");
    
    // 6. ATTEMPT CONNECTION
    logOutput.append("=== ATTEMPTING CONNECTION ===\n");
    long startTime = System.currentTimeMillis();
    
    try {
        con.connect();
        long connectTime = System.currentTimeMillis() - startTime;
        logOutput.append("Connection established in ").append(connectTime).append("ms\n");
    } catch (java.net.SocketTimeoutException e) {
        long timeoutTime = System.currentTimeMillis() - startTime;
        errorMessage = "Connection timeout after " + timeoutTime + "ms: " + e.getMessage();
        logOutput.append(errorMessage).append("\n");
        hasError = true;
        statusCode = 408;
        throw e;
    }
    
    // 7. SEND DATA
    logOutput.append("=== SENDING DATA ===\n");
    startTime = System.currentTimeMillis();
    
    os = new OutputStreamWriter(con.getOutputStream(), "UTF-8");
    os.write(jsonString);
    os.flush();
    os.close();
    
    long sendTime = System.currentTimeMillis() - startTime;
    logOutput.append("Data sent in ").append(sendTime).append("ms\n");
    
    // 8. READ RESPONSE
    logOutput.append("=== READING RESPONSE ===\n");
    startTime = System.currentTimeMillis();
    
    int responseCode = con.getResponseCode();
    logOutput.append("Response Code: ").append(responseCode).append("\n");
    logOutput.append("Response Message: ").append(con.getResponseMessage()).append("\n");
    
    // Print response headers
    logOutput.append("Response Headers:\n");
    for (int i = 1; ; i++) {
        String headerName = con.getHeaderFieldKey(i);
        String headerValue = con.getHeaderField(i);
        if (headerName == null && headerValue == null) break;
        logOutput.append("  ").append(headerName).append(": ").append(headerValue).append("\n");
    }
    
    StringBuffer content = new StringBuffer();
    
    if (responseCode >= 200 && responseCode < 300) {
        in = new BufferedReader(new InputStreamReader(con.getInputStream(), "UTF-8"));
        statusCode = 200;
    } else {
        in = new BufferedReader(new InputStreamReader(con.getErrorStream(), "UTF-8"));
        statusCode = responseCode;
        hasError = true;
    }
    
    String inputLine;
    while ((inputLine = in.readLine()) != null) {
        content.append(inputLine);
    }
    
    long readTime = System.currentTimeMillis() - startTime;
    logOutput.append("Response read in ").append(readTime).append("ms\n");
    logOutput.append("Response body: ").append(content.toString()).append("\n");
    
    // If successful, return success response
    if (!hasError) {
        String successMessage = "API call successful. Response: " + content.toString();
        out.print(responeObject(200, successMessage + "\nLog:\n" + logOutput.toString()));
    } else {
        String failureMessage = "API call failed with response code " + responseCode + ". Response: " + content.toString();
        out.print(responeObject(statusCode, failureMessage + "\nLog:\n" + logOutput.toString()));
    }
    
} catch (java.net.SocketTimeoutException e) {
    errorMessage = "SOCKET TIMEOUT: " + e.getMessage() + 
                  "\nThis indicates the server is not responding within the timeout period" +
                  "\nPossible causes:" +
                  "\n1. Firewall blocking outbound HTTPS connections" +
                  "\n2. Proxy configuration required" +
                  "\n3. Server is actually down/slow" +
                  "\n4. SSL/TLS version incompatibility";
    logOutput.append(errorMessage).append("\n");
    out.print(responeObject(408, errorMessage + "\nLog:\n" + logOutput.toString()));
    
} catch (java.net.ConnectException e) {
    errorMessage = "CONNECTION REFUSED: " + e.getMessage() +
                  "\nThis indicates the connection was actively rejected" +
                  "\nPossible causes:" +
                  "\n1. Wrong URL or port" +
                  "\n2. Firewall blocking the connection" +
                  "\n3. Server is down";
    logOutput.append(errorMessage).append("\n");
    out.print(responeObject(503, errorMessage + "\nLog:\n" + logOutput.toString()));
    
} catch (java.net.UnknownHostException e) {
    errorMessage = "UNKNOWN HOST: " + e.getMessage() +
                  "\nDNS resolution failed - check network connectivity";
    logOutput.append(errorMessage).append("\n");
    out.print(responeObject(502, errorMessage + "\nLog:\n" + logOutput.toString()));
    
} catch (javax.net.ssl.SSLException e) {
    errorMessage = "SSL EXCEPTION: " + e.getMessage() +
                  "\nSSL/TLS handshake failed - possible version incompatibility";
    logOutput.append(errorMessage).append("\n");
    out.print(responeObject(495, errorMessage + "\nLog:\n" + logOutput.toString()));
    
} catch (IOException e) {
    errorMessage = "IO EXCEPTION: " + e.getMessage();
    logOutput.append(errorMessage).append("\n");
    logOutput.append("Stack trace: ").append(e.getStackTrace().toString()).append("\n");
    out.print(responeObject(500, errorMessage + "\nLog:\n" + logOutput.toString()));
    
} catch (Exception e) {
    errorMessage = "GENERAL EXCEPTION: " + e.getMessage();
    logOutput.append(errorMessage).append("\n");
    logOutput.append("Stack trace: ").append(e.getStackTrace().toString()).append("\n");
    out.print(responeObject(500, errorMessage + "\nLog:\n" + logOutput.toString()));
    
} finally {
    // Cleanup
    logOutput.append("=== CLEANUP ===\n");
    if (os != null) {
        try { 
            os.close(); 
            logOutput.append("OutputStream closed\n");
        } catch (IOException e) { 
            logOutput.append("Error closing OutputStream: ").append(e.getMessage()).append("\n");
        }
    }
    if (in != null) {
        try { 
            in.close(); 
            logOutput.append("InputStream closed\n");
        } catch (IOException e) { 
            logOutput.append("Error closing InputStream: ").append(e.getMessage()).append("\n");
        }
    }
    if (con != null) {
        con.disconnect();
        logOutput.append("Connection disconnected\n");
    }
}

// CURL EQUIVALENT LOG
logOutput.append("\n=== CURL EQUIVALENT FOR TESTING ===\n");
logOutput.append("Try this curl command on the server:\n");
logOutput.append("curl -v -X POST https://pru-api-nprd.prudentialthailand.co.th/pru-service/uat1/auth/login \\\n");
logOutput.append("  -H 'Content-Type: application/json' \\\n");
logOutput.append("  -H 'Accept: application/json' \\\n");
logOutput.append("  -d '{\"username\":\"your_username\",\"password\":\"your_password\"}' \\\n");
logOutput.append("  --connect-timeout 10 --max-time 30\n");

// If no response was sent yet (shouldn't happen, but safety check)
if (!hasError && statusCode == 200) {
    // This should not execute if everything above worked correctly
    out.print(responeObject(200, "Diagnostic completed successfully\nLog:\n" + logOutput.toString()));
}

Test-NetConnection -ComputerName 45.60.49.148 -Port 443
